#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import codecs
import re
import sys
from collections import Counter
from optparse import OptionParser

"""
Script for converting the GDI shared task format into wapiti feature files

"""
sys.stdout = codecs.getwriter("utf-8")(sys.stdout.detach())
sys.stderr = codecs.getwriter("utf-8")(sys.stderr.detach())
sys.stdin = codecs.getreader("utf-8")(sys.stdin.detach())


word_len_counter = Counter()

tokencount = Counter()
freqcount = Counter()
labelcount = Counter()
print('main')
# generated by gdi2wapiti.py -
# """A)abcdefghijklmnopqrstuvwxyzàãäèéìòõöùúüǜ̀̃̆ẽZ"""

#
V = "aeiouàãäèéìòõöùúüǜẽ012345"
C = "bcdfghjklmnpqrstvwxzSK"

replacements = {'é': 'e1', 'ú': 'u1',
                    'à': 'a2', 'è': 'e2', 'ì': 'i2', 'ò': 'o2', 'ù': 'u2',
                    'ẽ': 'e3', 'õ': 'o3', 'ã': 'a3',
                    'ä': 'a0', 'ö': 'o0', 'ü': 'u0', 'ǜ': 'u5',

                    '̀': '_', '̃': '_', '̆': '_'
                }
"""Default character replacement"""


def replacespecial(string, char_replacement=replacements):
    """Return unicode string with special characters replaced"""

    return "".join(c if c not in char_replacement else char_replacement[c] for c in string)


def gdi2alphabet(options=None):
    """Return distribution of characters from stdin"""
    char_counter = Counter()
    for l in sys.stdin:
        l = l.strip().split('\t')
        if len(l) == 2:
            words, tag = l
            for w in words.split():
                char_counter.update(w)
    return char_counter


def gdi2wapiti(options=None):
    """Return """
    for l in sys.stdin:
        l = l.strip().split('\t')
        if len(l) == 1:
            l.append('ZH')
            print('# ADDING DUMMY LABEL', file=sys.stderr)
        if len(l) == 2:
            words, tag = l

            for w in words.split():
                if options.replacement:
                    w = replacespecial(w)
                word_len_counter[len(w)] += 1
                print("%s\t%s" % (w, tag))
            # print >> sys.stdout,  "%s\t%s" % ('____',tag)
            print()
        else:
            print('#PROBLEM LINE', l, file=sys.stderr)


def ngrams(chars, min_n, max_n):
    """Yield character n-grams between length min_n and max_n

    :param chars: sequence of items (e.g. characters)
    :param min_n: minimal length of n-grams
    :param max_n: maximal length of n-grams
    """

    n_tokens = len(chars)
    for i in range(n_tokens):
        for j in range(i + min_n, min(n_tokens, i + max_n) + 1):
            yield chars[i:j]


def cvshape(w):
    """Return the CV word shape features of a token"""

    wv = re.sub(r'[^%s]+' % V, '', w)
    wc = re.sub(r'[^%s]+' % C, '', w)
    wcs = "".join(sorted(set(re.sub(r'[^%s]+' % C, '', w))))
    wvs = "".join(sorted(set(re.sub(r'[^%s]+' % V, '', w))))
    # wcv = re.sub(r'[%s]+'%(V),'V',wc)
    wvv = re.sub(r'[%s]' % V, 'V', w)
    wcc = re.sub(r'[%s]' % C, 'C', w)
    wccvv = re.sub(r'[%s]' % V, 'V', wcc)
    return [
        "u:V=" + wv,
        "u:C=" + wc,
        "u:Cs=" + wcs,
        "u:Vs=" + wvs,
        #  "u:CV="+wcv,
        "u:VV=" + wvv,
        "u:CC=" + wcc,
        "u:CCVV=" + wccvv]


def b(s, name=""):
    """Return wapitified bigram output features"""
    return "b:%s=%s" % (name, s)


def u(s, name=""):
    """Return wapitified unigram output features"""
    return "u:%s=%s" % (name, s)


def s(s, name=""):
    """Return wapitified unigram/bigram output features"""
    return "*:%s=%s" % (name, s)


def featurize(options, w):
    """Return the extracted features of a word

    All words are in lowercase.
    The characters A and Z represent word boundaries.
    """

    # bigram output feature is always on
    r = ['b']  # 'u' was not useful
    # word feature
    r.append(u(w, name="WD"))
    # n-gram features
    ns = [u(n, name="NG") for n in ngrams("A" + w + "Z", 1, 6) if len(w) > len(n) + 2 and not n.isupper()]
    # prefix/suffix features
    sf = [u(w[:n] + w[-n:], name=("PS%d" % n)) for n in [1, 2, 3] if len(w) > 2 * n]
    r.extend(sf)
    r.extend(ns)
    if not options.no_cv_features:
        r.extend(cvshape(w))
    return r


def gdi2features(options, do_print=True):
    """Featurize GDI text directly into wapiti features

    Optionally suppress printing the features to stdout
    """
    ignored = 0
    for l in sys.stdin:
        l = l.strip().split('\t')
        # for test data we have no labels
        # use a dummy one
        if len(l) == 1:
            l.append('ZH')
            print('# ADDING DUMMY LABEL ZH', file=sys.stderr)

        if len(l) == 2:
            words, tag = l
            ws = words.split()
            ws_count = len(ws)
            tokencount[min(ws_count, 10)] += 1
            if ws_count < options.min_length:
                ignored += 1
                continue
            labelcount[tag] += 1
            for w in ws:
                w = w.replace('sch', 'S')  # replacement order is relevant
                w = w.replace('ch', 'K')
                if options.freqcount:
                    freqcount[w] += 1
                if options.replacement:
                    w = replacespecial(w)
                flist = featurize(options, w)
                if do_print:
                    print(" ".join(flist), tag)
            if do_print:
                print()
        else:
            print('# PROBLEM LINE', l, file=sys.stderr)
    print('# IGNORED_SEQ=', ignored, file=sys.stderr)


def process(options=None, args=None):
    """
    Process the command
    """
    if args:
        print('Error: command line arguments ignored! Read from stdin!', file=sys.stderr)
        exit(1)
    if options.wapiti:
        gdi2features(options)
        return

    if options.tokencount:
        gdi2features(options, do_print=False)
        for l in sorted(tokencount):
            print(l, tokencount[l], sep='\t')
        print(sum(tokencount.values()))

        if options.labelcount:
            for l in sorted(labelcount):
                print(l, labelcount[l], sep='\t')
            print(sum(labelcount.values()))

    if options.freqcount:
        gdi2features(options, do_print=False)
        for l in sorted(freqcount):
            print(l, freqcount[l], sep='\t')
        return

    if options.alphabet:
        char_counter = gdi2alphabet(options)
        for k in char_counter:
            print(k, char_counter[k], file=sys.stderr)
        print("".join(sorted(char_counter.keys())), file=sys.stdout)
        return

    gdi2wapiti(options)
    for k in word_len_counter:
        print(k, word_len_counter[k], file=sys.stderr)


def main():
    """
    Invoke this module as a script
    """

    parser = OptionParser(
        usage='%prog [OPTIONS] [ARGS...]',
        version='%prog 0.99',  #
        description='Convert GDI task format into wapiti feature file',
        epilog='Contact simon.clematide@uzh.ch'
    )
    parser.add_option('-l', '--logfile', dest='logfilename',
                      help='write log to FILE', metavar='FILE')
    parser.add_option('-q', '--quiet',
                      action='store_true', dest='quiet', default=False,
                      help='do not print status messages to stderr')
    parser.add_option('-d', '--debug',
                      action='store_true', dest='debug', default=False,
                      help='print debug information')
    parser.add_option('-a', '--alphabet',
                      action='store_true', dest='alphabet', default=False,
                      help='print alphabet on stdout')
    parser.add_option('-r', '--replacement',
                      action='store_true', dest='replacement', default=False,
                      help='replace special characters by ad-hoc transliteration')
    parser.add_option('-w', '--wapiti',
                      action='store_true', dest='wapiti', default=False,
                      help='output wapiti features')
    parser.add_option('-t', '--tokencount',
                      action='store_true', dest='tokencount', default=False,
                      help='output token count statistics')
    parser.add_option('-A', '--labelcount',
                      action='store_true', dest='labelcount', default=False,
                      help='output label count statistics')
    parser.add_option('-F', '--freqcount',
                      action='store_true', dest='freqcount', default=False,
                      help='count word frequencies')

    parser.add_option('-L', '--min_length',
                      action='store', dest='min_length', type=int, default=4,
                      help='minimum length %default')
    parser.add_option('-N', '--no_cv_features',
                      action='store_true', dest='no_cv_features', default=False,
                      help='do not generate cv word shape features %default')

    (options, args) = parser.parse_args()

    if options.debug:
        print("options=", options, file=sys.stderr)

    process(options=options, args=args)


if __name__ == '__main__':
    main()
